<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>OS | DevOpsエンジニアの備忘録</title>
  <link rel="stylesheet" href="/css/style.css" />
</head>
<body>

  <div class="site-container">

    <!-- Header -->
    <header class="site-header">
      <h1>Bash - sed/aws</h1>                                                          <!-- Topic Name -->
      <p class="tagline">
        Last Updated: 2026-02-12                                                <!-- Updated date -->
      </p>
    </header>

    <!-- Navigation Tabs -->
    <nav class="tabs">
      <a href="/index.html">HOME</a>
      <a href="/cloud/cloud-index.html">Cloud</a>
      <a href="/k8s/k8s-index.html" >Kubernetes</a>
      <a href="/auto/auto-index.html">Automation</a>
      <a href="/os/os-index.html" class="active">OS(Linux/Windows etc.)</a>     <!-- Tab Activation -->
      <a href="/db/db-index.html">DB</a>
      <a href="/network/network-index.html">Networking</a>
      <a href="/misc/misc-index.html">Misc</a>
      <a href="/about.html">About Me</a>
    </nav>

    <!-- Article Content -->
    <main class="content">
      <article class="info-card">
        <p>ファイルの編集に便利なsed/awkについてまとめます。</p>                                                <!-- Title -->
        <br>
        <h2>1. sed</h2>
        <h3>1-1. sedのメリット</h3>
        <p>ファイルの中の特定の文字列を置換・削除したり、文字列を追加したりするコマンドですが、構造がフラットな構成ファイルの編集や機密情報のマスクに便利です(jsonやyamlはjq/yqを使うほうが安全です)。</p>
        <br>
        <h3>1-2. sedの基本</h3>
        <p>構文: </p>
        <pre><code>sed [オプション] 'スクリプト' ファイル
例) sed -E -i.buckup 's/pattern/replacement' file1</code></pre>
        <p>重要ポイント:</p>
        <ul>
            <li>頻出オプション1: -i(in-place)でファイルを直接編集します。また、-i.backupとすることでファイルの編集前にバックアップを取得します。</li>
            <li>頻出オプション2: -EでERE(Extended Regex)が使えます。</li>
            <li>スクリプトが's/pattern/replacement/'の場合、文字列patternを文字列replacementで置換します。</li>
            <li>置換の際's/pattern/replacement/g'とすると全て置換されます(gなしだと1つだけ)。</li>
            <li>スクリプトが'/pattern/a string'の場合、patternの次の行にstringが追加される</li>
            <li>スクリプトが'/pattern/i string'の場合、patternの前の行にstringが追加される</li>
            <li>スクリプトが置換の場合、sに続く文字が区切り文字になる。/の他には|や#が使われる。</li>
            <li>置換時&はマッチした文字列全体、\1, \2はキャプチャグループを指す。</li>
            <li>インデントはハードコードでも良いが[[:space:]]とキャプチャグループを組み合わせて使う方法もある。</li>
            <li>インデントは上記の方法で対処できますが、Yamlなどはyqコマンドで編集するのが良いでしょう。</li>            
        </ul>
        <p>参考: </p>
        <ul>
            <li><a href="https://www.gnu.org/software/sed/manual/html_node/Command_002dLine-Options.html">2.2 Command-Line Options</a></li>
            <li><a href="https://www.gnu.org/software/findutils/manual/html_node/find_html/posix_002dextended-regular-expression-syntax.html">8.5.10 ‘posix-extended’ regular expression syntax</a></li>
        </ul>
        <br>
        <h3>1-3. sedの動作確認</h3>
        <p>こちらのファイルで色々と試していきます。</p>
        <pre><code>$ cat linux-sed-varfile.tfvars 
# Application Configuration
app_name = "myapp"
app_env  = "development"
app_debug = true

# Database
db_host = "localhost"
db_port = 5432
db_user = "admin"
db_pass = "secret"</code></pre>
        <br>
        <p>例) s/ - DBパスワードにマスクをかけます。</p>
        <pre><code>$ sed -E 's/^(db_pass = )(.*)/\1xxxx/' linux-sed-varfile.tfvars
# Application Configuration
app_name = "myapp"
app_env  = "development"
app_debug = true

# Database
db_host = "localhost"
db_port = 5432
db_user = "admin"
db_pass = xxxx</code></pre>
        <br>
        <p>例) a/ - db_nameを足します。</p>
        <pre><code>$ sed '/# Database/a db_name = "myappdb"' linux-sed-varfile.tfvars
# Application Configuration
app_name = "myapp"
app_env  = "development"
app_debug = true

# Database
db_name = "myappdb"
db_host = "localhost"
db_port = 5432
db_user = "admin"
db_pass = "secret"</code></pre>
        <br>
        <h2>2. awk</h2>
        <h3>2-1. awkのメリット</h3>
        <p>awkのメリットはテキストデータの構造を欲しい形に作り直すことができる、また元データに基づいて簡単な計算をして必要なデータを作ることができることにあると思います。例えば、CLIの出力結果やログの整形に便利そうですね。</p>
        <br>
        <h3>2-2. awsの基本</h3>
        <h4>構文</h4>
        <pre><code>awk 'filter { some processing } END { final actions }' file
例: awk '$5+0 > 80 { print $1, $5 }' file.txt #5列目が80より大きい場合は1列目と5列目を表示</code></pre>
        <p>重要ポイント:</p>
        <ul>
            <li>ENDは様々な処理をした後にprintすることを示します。</li>
            <li>filterにはregexを含む文字列の比較、数値比較などが可能です。</li>
            <li>$1 ~ /pattern/は1列目の値がpatternを含む行を抽出</li>
            <li>$1 == "pattern"は1列目の値がpatternと完全に一致する行を抽出</li>
            <li>KBなどの単位が含まれる場合、+0とすると単位を除去できます。</li>
            <li>-Fにて元データのField Separatorを指定できます。</li>
            <li>BEGIN { OFS="," }のようにOFSにて出力時のField Separatorも指定できます。</li>
            <li>{ count[$1]++ }にて1列目の値の出現回数をカウントできます。</li>
            <li>{ sum[$1] += $2 }にて1列目が特定の値のときの2列目の値の合計値を計算できます。</li>
            <li>END { for (k in count) print k, count[k] }で上記でカウントした結果を出力できます。</li>
            <li>awkはforだけでなく、if文も備えています。</li>
        </ul>
        <br>
        <h3>2-3. 動作確認</h3>
        <p>サンプルデータファイルは<a href="/os/linux-awk-sample-data.txt">こちら</a>を使います。</p>
        <p>例) ERRORを含む行の$1を出力 ※$0は行全体を意味します</p>
        <pre><code>$ awk '$0 ~ /ERROR/ { print $1 }' linux-awk-sample-data.txt 
192.168.1.10
10.0.0.2
10.0.0.1</code></pre>
        <p>例) Use%が80%以上のFilesystemを抽出</p>
        <pre><code>$ awk 'NR>1 && $5+0 > 80 { print $1, $5 }' linux-awk-sample-data.txt 
/dev/sda1 85%
/dev/sdb1 90%</code></pre>
        <p>例) サーバログをCSVに変換</p>
        <pre><code>$ awk 'BEGIN { OFS="," } $1 ~ /^[1-9]{1,3}.*/ { print $1, $2, $3 }' linux-awk-sample-data.txt 
192.168.1.10,ERROR,Disk
10.0.0.1,INFO,System
192.168.1.11,WARNING,CPU
10.0.0.2,ERROR,Network
192.168.1.12,INFO,Backup
192.168.1.10,WARNING,Memory
10.0.0.1,ERROR,Disk</code></pre>
        <p>例) bobの出現回数をカウント</p>
        <pre><code>$ awk '$1 =="bob" { count[$1]++ } END { for (k in count) print k, count[k] }' linux-awk-sample-data.txt 
bob 3</code></pre>
        <p>例)bobとaliceのスコアの合計値</p>
        <pre><code>$ awk '$1=="bob"||$1=="alice" { sum1[$1] += $2; sum2[$1] += $3 } END { for (c in sum1) print c,sum1[c],sum2[c]}' linux-awk-sample-data.txt 
bob 6 14
alice 15 3</code></pre>
        <br>
        <h2>3. 感想</h2>
        <p>awkの最後の例を試してる時におかしなハマり方をしてしまいました。</p>
        <pre><code>$ awk '$1=="bob"||$1=="alice" { sum1[$1] += $2; sum2[$1] += $3 } END { for (c in sum1) print $1,sum1[c],sum2[c]
}' linux-awk-sample-data.txt 
/dev/sdc1 6 14
/dev/sdc1 15 33</code></pre>
        <p>END{}内のforにてcと書くべきところが$1になっていたことが原因でした。お恥ずかしい。。</p>
      </article>
    </main>

    <footer class="site-footer">
      <p>© 2026 takatora</p>
    </footer>
  </div>
</body>
</html>
